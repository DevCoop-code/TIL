# Swift

****

## Enumeration
1. 기본 열거형
   - DataType/EnumPractice01.playground
2. 열거형 응용
   - DataType/EnumPractice02.playground

****

## 연산자
### 사용자 정의 연산자
사용자(프로그래머)의 입맛에 맞게 연산자 역할을 부여하는 것이 가능. 또는 기존에 존재하지 않던 연산자 기호를 만들어 추가하는 것이 가능
#### 전위, 중위, 후위 연산자
- 전위연산자
  - 연산자가 피연산자 앞에 위치하는 연산자
  - Ex) !A
  - keyword: prefix
- 중위연산자
  - 피연산자 사이에 위치하는 연산자
  - Ex) A + B
  - keyword: infix
- 후위연산자
  - 피연산자 뒤에 위치하는 연산자
  - Ex) 0! //옵셔널 강제 추출
  - keyword: postfix
#### 그 외 keyword들
- operator: 연산자
- associativity: 연산자 결합방향
- precedence: 우선순위

### 연산자 정의와 구현
기존에 없던 전위 연산자를 만들고 싶다면 연산자 정의를 먼저 해주어야 함<br>
Ex) prefix operator ** //전위 연산자 정의 <br>
정의 한다는 뜻은 '이제 이 연산자를 사용하겠다'라고 알리는 것을 의미<br>
정의된 연산자는 모듈 전역에서 사용 가능 <br>
전위 연산자와 후위 연산자는 사용방법이 유사(prefix, postfix 그리고 후위 연산지 전위 연산보다 우선이라는 것 정도의 차이)<br>
BUT! **중위 연산자는 우선순위 그룹을 명시해줄수 있음** 연산자 우선순위 그룹은 precedencegroup 뒤에 그룹 이름을 사용해 정의 가능

****

## Property
1. 저장 프로퍼티(Stored Properties)
   - 인스턴스의 변수 또는 상수 의미
2. 연산 프로퍼티(Computed Properties)
   - 값을 저장하는 것이 아닌 특정 연산을 실행한 결과값을 의미(ex]get,set 변수)
3. 타입 프로퍼티(Type Properties)
   - Property/TypeProperty.playground
- 지연저장 프로퍼티(lazy stored properties)
  - 호출이 있어야 값을 초기화, lazy 키워드를 사용
- 프로퍼티 감시자(Property Observers)
  - 프로퍼티의 값이 변경됨에 따라 적절한 작업을 취할 수 있게 해주는 기능
  - Property/PropertyObservers.playground

****

## Method
### mutating
클래스 내의 함수가 자신의 프로퍼티 값을 수정할 때 클래스의 인스턴스 메서드는 크게 신경쓸 필요가 없음. <br> 
But, 구조체나 열거형 등의 값 타입에서 사용하는 함수가 구조체나 열거형 등의 내부 값을 변경하는 함수가 있을 경우에는 내부의 값을 변경한다는 것을 암시하기 위해 **mutating** 키워드를 붙여서 이를 명시해야 함.

### Type Method
메서드에는 2가지 메서드가 있음(인스턴스 메서드, 타입 메서드)
타입 자체에 호출이 가능한 메서드를 타입 메서드라 부르고 메서드 앞에 **static** 또는 **class** 키워드를 사용<br>
static으로 정의하면 상속 후 메서드 재정의가 불가능하고 class로 정의하면 상속 후 메서드 재정의가 가능

### 가변 매개변수와 입출력 매개변수
#### 가변 매개변수
- 가면 매개변수는 0개 이상(0개 포함)의 값을 받아올 수 있음 
- 가변 매개변수로 들어온 인자 값은 배열처럼 사용이 가능
- 함수마다 가변 매개변수는 하나만 사용이 가능

#### 입출력 매개변수
함수의 전달인자로 값을 전달할 때 보통 값을 복사해서 전달 But, 값이 아닌 참조를 전달하려면 입출력 매개변수를 사용. 값 타입 데이터의 참조를 전달인자로 보내면 함수 내부에서 참조하여 원래 값을 변경<br>
참조는 inout 매개변수로 전달될 변수 또는 상수 앞에 **&**을 붙여 표현

****

## Closure
함수는 클로저의 한 형태

- 클로저의 3가지 형태
  - 이름이 있으면서 어떤 값도 획득하지 않는 전역함수의 형태
  - 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 중첩된 함수의 형태
  - 이름이 없고, 주변 문맥에 따라 값을 획득할 수 있는 축약 문법으로 작성한 형태

- Closure/Closure01.playground

클로저 표현 방법은 클로저의 위치를 기준으로 크게 **기본 클로저 표현**과 **후행 클로저 표현**이 있음.

### 기본 클로저
클로저 통상적 표현 방식<br>
{
   (매개변수들) -> 반환 타입 in 실행코드
}
### 후행 클로저
 함수나 멧서드의 마지막 전달인자로 위치하는 클로저는 함수나 멧서드의 소괄호를 닫은 후 작성해도 가능 이것을 후행 클로저(Trailing Closure)라고 함<br>
클로저가 길어져 가독성이 떨어진다면 후행 클로저 사용을 추천<br>
후행 클로저는 맨 마지막 전달인자로 전달되는 클로저에만 해당됨. 전달인자로 클로저 여러 개를 전달할 때는 맨 마지막 클로저만 후행 클로저로 사용가능 그리고 단 하나의 클로저만 전달인자로 전달하는 경우에는 소괄호를 생략

### 클로저 표현 간소화
- 문맥을 이용한 타입 유추
  - 메서드의 전달인자로 전달하는 클로저는 메서드에서 요구하는 형태로 전달해야 함
  - 매개변수의 타입이나 개수, 반환 타입 등이 같아야 전달인자로서 전달이 가능
  - 그래서 전달인자로 전달하는 클로저를 구현할 때는 매개변수의 타입이나 반환 값의 타입을 굳이 표현해주지 않고 생략하더라도 문제가 없음
- 단축 인자 이름
  - 매개변수 이름을 요약하여 단축인자 이름을 제공
  - 단축 인자 이름은 첫번째 전달인자부터 $0, $1, $2, ... 순서로 $와 숫자의 조합으로 표현
  - 단축 인자 표현을 사용하게 되면 매개변수 및 반환 타입과 실행코드를 구분하기 위한 in 키워드를 사용할 필요 또한 없어짐

### 값 획득
클로저는 자신이 정의된 위치의 주변 문맥을 통해 상수나 변수를 획득할수 있음.<br>
획득을 통해 클로저는 주변에 정의한 상수나 변수가 더 이상 존재하지 않더라도 해당 상수나 변수의 값을 자신 내부에서 참조하거나 수정할 수 있음

### 탈출 클로저
함수의 전달인자로 전달한 클로저가 함수 종료 후에 호출될 때 클로저가 함수를 탈출(Escape)한다고 표현.<br>
클로저를 매개변수로 갖는 함수를 선언할 때 매개변수 이름의 콜론(:) 뒤에 @escaping 키워드를 사용하여 클로저가 탈출하는 것을 허용한다고 명시할 수 있음.<br>
@escaping 키워드를 따로 명시하지 않는다면 매개변수로 사용되는 클로저는 기본으로 비탈출 클로저(Nonescape Closure).

### withoutActuallyEscaping
비탈출 클로저로 전달한 클로저가 탈출 클로저인 척 해야하는 경우가 존재 -> 실제로는 탈출하지 않지만 다른 함수에서 탈출 클로저를 요구하는 상황이 이에 해당<br>
이때 해당 클로저를 탈출 클로저인양 사용할 수 있게 돕는 **withoutActuallyEscaping(_:do:)** 함수를 사용

### 자동 클로저
함수의 전달인자로 전달하는 표현을 자동으로 변환해주는 클로저를 자동클로저(Auto Closure)라 함<br>
**자동 클로저는 전달인자를 갖지 않습니다** <br>
자동 클로저는 함수로 전달하는 클로저를 어려운 클로저 문법(소괄호와 중괄호를 겹쳐써야 하는)을 사용하지 않고도 클로저를 사용할 수 있도록 문법적 편의를 제공<br>
**자동클로저는 클로저가 호출되기 전까지 클로저 내부의 코드가 동작 X, 따라서 연산을 지연시킬 수 있습니다. 연산에 자원을 많이 소모한다거나 부작용이 우려될 때 유용하게 사용할 쑤 있음(코드의 실행을 제어하기 좋음)** <br>
@autoclosure를 사용하여 자동 클로저 임을 암시 <br>
@autoclosure 속성은 @noescape 속성을 포함. @autoclosure 속성을 사용하면 @noescape 속성도 부여됨을 암시. 만약 자동 클로저를 탈출하는 클로저를 사용하고 싶다면 @autoclosure 속성 뒤에 @escaping 속성을 덧붙여서 **@autoclosure @escaping** 처럼 사용해야 함

****

## 옵셔널 체이닝과 빠른 종료
옵셔널을 반복 사용하여 옵셔널이 자전거 체인처럼 서로 꼬리를 물고 있는 모양이기에 옵셔널 체이닝이라 함.<br>
옵셔널 체이닝은 프로퍼티나 메서드 또는 서브스크립트를 호출하고 싶은 옵셔널 변수나 상수 뒤에 물음표(?)를 붙여 표현. 옵셔널이 nil이 아니라면 정상적으로 호출, nil이라면 결과값으로 nil을 반환.<br>
옵셔널 체이닝을 통해 메서드와 서브스크립트 호출도 가능
- Optional/OptionalSample.playground

****

## 타입캐스팅
스위프트는 데이터 타입 안전을 위해 각기 다른 타입끼리의 값 교환을 엄격히 제한 <br>
암시적 데이터 타입 변환(Implicit Type Conversion)은 지원하지 않음<br>
스위프트의 타입캐스팅은 인스턴스의 타입을 확인하거나 자신을 다른 타입의 인스턴스인양 행세할 수 있는 방법으로 사용이 가능<br>
스위프트의 타입캐스팅은 **is**와 **as** 연산자로 구현
### 데이터 타입 확인
타입 확인 연산자인 is를 활용하여 인스턴스가 어떤 클래스의 인스턴스인지 타입을 확인할 수 있음

### 메타 타입
메타타입 타입은 타입의 타입을 뜻함.<br>
클래스, 구조체, 열거형의 이름은 타입의 이름. 그 타입의 이름 뒤에 .Type을 붙이면 이는 메타타입을 나타냄 <br>
또, self를 이용해서 타입을 값처럼 표현이 가능<br>
만약 프로그램 실행 중에 인스턴스의 타입을 표현한 값을 알아보고자 한다면 **type(of:)** 함수를 사용

### 다운캐스팅
클래스의 상속 모식도에서 자식 클래스보다 더 상위에 있는 부모클래스의 타입을 자식 클래스의 타입으로 캐스팅하는 것<br>
타입 캐스트 연산자(Type Cast Operator)에는 **as?**와 **as!** 2가지가 존재. 타입 캐스트 연산자를 사용하여 자식클래스 타입으로 다운캐스트 할 수 있음
#### 타입 캐스트 연산자
- as?: 타입 캐스트 실패시 nil을 반환, 반환 타입이 옵셔널
- as!: 타입 캐스트 실패시 런타임 오류 발생, 반환 타입이 옵셔널이 아님

### Any, AnyObject의 타입 캐스팅
Any와 AnyObject는 특정 타입을 지정하지 않고 여러 타입의 값을 할당할 수 있는 타입.<br>
Any는 함수 타입을 포함한 모든 타입을 의미하고 AnyObject는 클래스 타입만을 뜻함

****

## 프로토콜
### 프로토콜 이란?
Protocol은 특정 역할을 하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 청사진을 정의. 즉 프로토콜은 정의를 하고 제시를 할 뿐 스스로 기능을 구현하지는 않음

### 프로토콜 요구사항
#### 프로퍼티 요구
프로토콜은 자신을 채택한 타입이 어떤 프로퍼티를 구현해야 하는지 요구할 수 있음<br>
프로퍼티를 읽기 전용으로 할지 혹은 읽고 쓰기가 모두 가능하게 할지는 프로토콜이 프로퍼티를 요구할때 정해야 함 <br>
프로토콜의 프로퍼티 요구사항은 항상 var 키워드를 사용한 변수 프로퍼티로 정의. 읽기와 쓰기가 모두 가능한 프로퍼티는 프로퍼티의 정의 뒤에 { get, set }을 명시, 읽기 전용 프로퍼티는 정의 뒤에 { get }이라고 명시.

#### 가변 메서드 요구
프로토콜이 어떤 타입이든 간에 인스턴스 내부의 값을 변경해야 하는 메서드를 요구하려면 프로토콜의 메서드 정의 앞에 mutating 키워드를 명시해야만 함 But, 프로토콜에 mutating 키워드를 사용한 메소드 요구가 있다 하더라도 클래스 구현에서는 mutating 키워드를 써주지 않아도 됨.

#### 이니셜라이저 요구
특정한 이니셜라이저를 요구할 수 있음.<br>
구조체는 상속할 수 없기 때문에 이니셜라이저 요구에 신경쓸 필요 X But 클래스는 상속이 가능하기에 이니셜라이져 요구에 대해 **required** 식별자를 붙여야 함. 이는 상속 받는 모든 클래스가 프로토콜의 이니셜라이져 요구를 준수해야함을 의미.

### 클래스 전용 프로토콜
프로토콜의 상속 리스트에 class 키워드를 추가해 프로토콜이 클래스 타입에만 채택될 수 있도록 제한할 수 있음. 클래스 전용 프로토콜로 제한을 주기 위해서는 프로토콜의 상속 리스트의 맨 처음에 class 키워드가 위치해야만 함

### 프로토콜 조합과 프로토콜 준수 확인
하나의 매개변수가 여러 프로토콜을 모두 준수하는 타입이어야 한다면 하나의 매개변수에 여러 프로토콜을 한 번에 조합하여 요구할 수 있음<br>
**SomeProtocol & AnotherProtocol** 과 같이 표현. 이렇게 &를 붙여 여러 프로토콜 이름 사이에 써주면 됨

### 프로토콜의 선택적 요구
프로토콜의 요구사항 중 일부를 선택적 요구사항으로 지정할 수 있음<br>
선택적 요구사항을 정의하고 싶은 프로토콜은 **objc** 속성이 부여된 프로토콜이어먄 함. objc 속성은 해당 프로토콜을 Objective-C 코드에서 사용할 수 있도록 만드는 역할 하지만 굳이 Objective-C 코드와 공유하지 않더라도 objc 속성이 부여되어야만 선택적 요구사항을 정의할 수 있음 하지만 이 뜻은 열거형이나 구조체 등에서는 objc 속성이 부여된 프로토콜은 아예 채택할 수 없다는 것을 의미<br>
선택적 요구를 하면 프로토콜을 준수하는 타입에 해당 요구사항을 필수로 구현할 필요는 없음. **선택적 요구사항은 optional 식별자를 요구사항의 정의 앞에 붙여주면 됨**

****

## 제네릭
제네릭을 이용해 코드를 구현하는 어떤 타입에도 유연하게 대응이 가능. 제네릭으로 구현한 기능과 타입은 재사용이 용이하고 코드의 중복을 줄여 추상적 표현이 가능<br>
제네릭이 필요한 타입 또는 메서드의 이름 뒤에 화살괄호 기호(<>) 사이에 제네릭을 위한 타입 매개변수를 써주어 제네릭을 사용할 것임을 표시<br>
- Ex] <br>
제네릭을 사용하고자 하는 타입 이름 <타입 매개변수><br>
제네릭을 사용하고자 하는 함수 이름 <타입 매개변수> (함수의 매개변수...)
