# Swift

****

## Enumeration
1. 기본 열거형
   - DataType/EnumPractice01.playground
2. 열거형 응용
   - DataType/EnumPractice02.playground

****

## 연산자
### 사용자 정의 연산자
사용자(프로그래머)의 입맛에 맞게 연산자 역할을 부여하는 것이 가능. 또는 기존에 존재하지 않던 연산자 기호를 만들어 추가하는 것이 가능
#### 전위, 중위, 후위 연산자
- 전위연산자
  - 연산자가 피연산자 앞에 위치하는 연산자
  - Ex) !A
  - keyword: prefix
- 중위연산자
  - 피연산자 사이에 위치하는 연산자
  - Ex) A + B
  - keyword: infix
- 후위연산자
  - 피연산자 뒤에 위치하는 연산자
  - Ex) 0! //옵셔널 강제 추출
  - keyword: postfix
#### 그 외 keyword들
- operator: 연산자
- associativity: 연산자 결합방향
- precedence: 우선순위

### 연산자 정의와 구현
기존에 없던 전위 연산자를 만들고 싶다면 연산자 정의를 먼저 해주어야 함<br>
Ex) prefix operator ** //전위 연산자 정의 <br>
정의 한다는 뜻은 '이제 이 연산자를 사용하겠다'라고 알리는 것을 의미<br>
정의된 연산자는 모듈 전역에서 사용 가능 <br>
전위 연산자와 후위 연산자는 사용방법이 유사(prefix, postfix 그리고 후위 연산지 전위 연산보다 우선이라는 것 정도의 차이)<br>
BUT! **중위 연산자는 우선순위 그룹을 명시해줄수 있음** 연산자 우선순위 그룹은 precedencegroup 뒤에 그룹 이름을 사용해 정의 가능

****

## Property
1. 저장 프로퍼티(Stored Properties)
   - 인스턴스의 변수 또는 상수 의미
2. 연산 프로퍼티(Computed Properties)
   - 값을 저장하는 것이 아닌 특정 연산을 실행한 결과값을 의미(ex]get,set 변수)
3. 타입 프로퍼티(Type Properties)
   - Property/TypeProperty.playground
- 지연저장 프로퍼티(lazy stored properties)
  - 호출이 있어야 값을 초기화, lazy 키워드를 사용
- 프로퍼티 감시자(Property Observers)
  - 프로퍼티의 값이 변경됨에 따라 적절한 작업을 취할 수 있게 해주는 기능
  - Property/PropertyObservers.playground

****

## Method
### mutating
클래스 내의 함수가 자신의 프로퍼티 값을 수정할 때 클래스의 인스턴스 메서드는 크게 신경쓸 필요가 없음. <br> 
But, 구조체나 열거형 등의 값 타입에서 사용하는 함수가 구조체나 열거형 등의 내부 값을 변경하는 함수가 있을 경우에는 내부의 값을 변경한다는 것을 암시하기 위해 **mutating** 키워드를 붙여서 이를 명시해야 함.

### Type Method
메서드에는 2가지 메서드가 있음(인스턴스 메서드, 타입 메서드)
타입 자체에 호출이 가능한 메서드를 타입 메서드라 부르고 메서드 앞에 **static** 또는 **class** 키워드를 사용<br>
static으로 정의하면 상속 후 메서드 재정의가 불가능하고 class로 정의하면 상속 후 메서드 재정의가 가능

### 가변 매개변수와 입출력 매개변수
#### 가변 매개변수
- 가면 매개변수는 0개 이상(0개 포함)의 값을 받아올 수 있음 
- 가변 매개변수로 들어온 인자 값은 배열처럼 사용이 가능
- 함수마다 가변 매개변수는 하나만 사용이 가능

#### 입출력 매개변수
함수의 전달인자로 값을 전달할 때 보통 값을 복사해서 전달 But, 값이 아닌 참조를 전달하려면 입출력 매개변수를 사용. 값 타입 데이터의 참조를 전달인자로 보내면 함수 내부에서 참조하여 원래 값을 변경<br>
참조는 inout 매개변수로 전달될 변수 또는 상수 앞에 **&**을 붙여 표현

****

## Closure
함수는 클로저의 한 형태

- 클로저의 3가지 형태
  - 이름이 있으면서 어떤 값도 획득하지 않는 전역함수의 형태
  - 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 중첩된 함수의 형태
  - 이름이 없고, 주변 문맥에 따라 값을 획득할 수 있는 축약 문법으로 작성한 형태

- Closure/Closure01.playground

클로저 표현 방법은 클로저의 위치를 기준으로 크게 **기본 클로저 표현**과 **후행 클로저 표현**이 있음.

### 기본 클로저
클로저 통상적 표현 방식<br>
{
   (매개변수들) -> 반환 타입 in 실행코드
}
### 후행 클로저
 함수나 멧서드의 마지막 전달인자로 위치하는 클로저는 함수나 멧서드의 소괄호를 닫은 후 작성해도 가능 이것을 후행 클로저(Trailing Closure)라고 함<br>
클로저가 길어져 가독성이 떨어진다면 후행 클로저 사용을 추천<br>
후행 클로저는 맨 마지막 전달인자로 전달되는 클로저에만 해당됨. 전달인자로 클로저 여러 개를 전달할 때는 맨 마지막 클로저만 후행 클로저로 사용가능 그리고 단 하나의 클로저만 전달인자로 전달하는 경우에는 소괄호를 생략

### 클로저 표현 간소화
- 문맥을 이용한 타입 유추
  - 메서드의 전달인자로 전달하는 클로저는 메서드에서 요구하는 형태로 전달해야 함
  - 매개변수의 타입이나 개수, 반환 타입 등이 같아야 전달인자로서 전달이 가능
  - 그래서 전달인자로 전달하는 클로저를 구현할 때는 매개변수의 타입이나 반환 값의 타입을 굳이 표현해주지 않고 생략하더라도 문제가 없음
- 단축 인자 이름
  - 매개변수 이름을 요약하여 단축인자 이름을 제공
  - 단축 인자 이름은 첫번째 전달인자부터 $0, $1, $2, ... 순서로 $와 숫자의 조합으로 표현
  - 단축 인자 표현을 사용하게 되면 매개변수 및 반환 타입과 실행코드를 구분하기 위한 in 키워드를 사용할 필요 또한 없어짐

### 값 획득
클로저는 자신이 정의된 위치의 주변 문맥을 통해 상수나 변수를 획득할수 있음.<br>
획득을 통해 클로저는 주변에 정의한 상수나 변수가 더 이상 존재하지 않더라도 해당 상수나 변수의 값을 자신 내부에서 참조하거나 수정할 수 있음

### 탈출 클로저
함수의 전달인자로 전달한 클로저가 함수 종료 후에 호출될 때 클로저가 함수를 탈출(Escape)한다고 표현.<br>
클로저를 매개변수로 갖는 함수를 선언할 때 매개변수 이름의 콜론(:) 뒤에 @escaping 키워드를 사용하여 클로저가 탈출하는 것을 허용한다고 명시할 수 있음.<br>
@escaping 키워드를 따로 명시하지 않는다면 매개변수로 사용되는 클로저는 기본으로 비탈출 클로저(Nonescape Closure).

### withoutActuallyEscaping
비탈출 클로저로 전달한 클로저가 탈출 클로저인 척 해야하는 경우가 존재 -> 실제로는 탈출하지 않지만 다른 함수에서 탈출 클로저를 요구하는 상황이 이에 해당<br>
이때 해당 클로저를 탈출 클로저인양 사용할 수 있게 돕는 **withoutActuallyEscaping(_:do:)** 함수를 사용

### 자동 클로저
함수의 전달인자로 전달하는 표현을 자동으로 변환해주는 클로저를 자동클로저(Auto Closure)라 함<br>
**자동 클로저는 전달인자를 갖지 않습니다** <br>
자동 클로저는 함수로 전달하는 클로저를 어려운 클로저 문법(소괄호와 중괄호를 겹쳐써야 하는)을 사용하지 않고도 클로저를 사용할 수 있도록 문법적 편의를 제공<br>
**자동클로저는 클로저가 호출되기 전까지 클로저 내부의 코드가 동작 X, 따라서 연산을 지연시킬 수 있습니다. 연산에 자원을 많이 소모한다거나 부작용이 우려될 때 유용하게 사용할 쑤 있음(코드의 실행을 제어하기 좋음)** <br>
@autoclosure를 사용하여 자동 클로저 임을 암시 <br>
@autoclosure 속성은 @noescape 속성을 포함. @autoclosure 속성을 사용하면 @noescape 속성도 부여됨을 암시. 만약 자동 클로저를 탈출하는 클로저를 사용하고 싶다면 @autoclosure 속성 뒤에 @escaping 속성을 덧붙여서 **@autoclosure @escaping** 처럼 사용해야 함

****

## 옵셔널 체이닝과 빠른 종료
옵셔널을 반복 사용하여 옵셔널이 자전거 체인처럼 서로 꼬리를 물고 있는 모양이기에 옵셔널 체이닝이라 함.<br>
옵셔널 체이닝은 프로퍼티나 메서드 또는 서브스크립트를 호출하고 싶은 옵셔널 변수나 상수 뒤에 물음표(?)를 붙여 표현. 옵셔널이 nil이 아니라면 정상적으로 호출, nil이라면 결과값으로 nil을 반환.<br>
옵셔널 체이닝을 통해 메서드와 서브스크립트 호출도 가능
- Optional/OptionalSample.playground

****

## 타입캐스팅
스위프트는 데이터 타입 안전을 위해 각기 다른 타입끼리의 값 교환을 엄격히 제한 <br>
암시적 데이터 타입 변환(Implicit Type Conversion)은 지원하지 않음<br>
스위프트의 타입캐스팅은 인스턴스의 타입을 확인하거나 자신을 다른 타입의 인스턴스인양 행세할 수 있는 방법으로 사용이 가능<br>
스위프트의 타입캐스팅은 **is**와 **as** 연산자로 구현
- **is**: 인스턴스가 어떤 클래스의 인스턴스인지 타입을 확인해볼수 있음
- **as**: 다운 캐스팅(부모 클래스의 타입을 자식 클래스의 타입으로 캐스팅)
  - **as?**: 다운캐스팅 실패시 nil 반환
  - **as!**: 다운캐스팅 실패시 Runtime Error 발생
### 데이터 타입 확인
타입 확인 연산자인 is를 활용하여 인스턴스가 어떤 클래스의 인스턴스인지 타입을 확인할 수 있음

### 메타 타입
메타타입 타입은 타입의 타입을 뜻함.<br>
클래스, 구조체, 열거형의 이름은 타입의 이름. 그 타입의 이름 뒤에 .Type을 붙이면 이는 메타타입을 나타냄 <br>
또, self를 이용해서 타입을 값처럼 표현이 가능<br>
만약 프로그램 실행 중에 인스턴스의 타입을 표현한 값을 알아보고자 한다면 **type(of:)** 함수를 사용

### 다운캐스팅
클래스의 상속 모식도에서 자식 클래스보다 더 상위에 있는 부모클래스의 타입을 자식 클래스의 타입으로 캐스팅하는 것<br>
타입 캐스트 연산자(Type Cast Operator)에는 **as?**와 **as!** 2가지가 존재. 타입 캐스트 연산자를 사용하여 자식클래스 타입으로 다운캐스트 할 수 있음
#### 타입 캐스트 연산자
- as?: 타입 캐스트 실패시 nil을 반환, 반환 타입이 옵셔널
- as!: 타입 캐스트 실패시 런타임 오류 발생, 반환 타입이 옵셔널이 아님

### Any, AnyObject의 타입 캐스팅
Any와 AnyObject는 특정 타입을 지정하지 않고 여러 타입의 값을 할당할 수 있는 타입.<br>
Any는 함수 타입을 포함한 모든 타입을 의미하고 AnyObject는 클래스 타입만을 뜻함

****

## 프로토콜
### 프로토콜 이란?
Protocol은 특정 역할을 하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 청사진을 정의. 즉 프로토콜은 정의를 하고 제시를 할 뿐 스스로 기능을 구현하지는 않음

### 프로토콜 요구사항
#### 프로퍼티 요구
프로토콜은 자신을 채택한 타입이 어떤 프로퍼티를 구현해야 하는지 요구할 수 있음<br>
프로퍼티를 읽기 전용으로 할지 혹은 읽고 쓰기가 모두 가능하게 할지는 프로토콜이 프로퍼티를 요구할때 정해야 함 <br>
프로토콜의 프로퍼티 요구사항은 항상 var 키워드를 사용한 변수 프로퍼티로 정의. 읽기와 쓰기가 모두 가능한 프로퍼티는 프로퍼티의 정의 뒤에 { get, set }을 명시, 읽기 전용 프로퍼티는 정의 뒤에 { get }이라고 명시.

#### 가변 메서드 요구
프로토콜이 어떤 타입이든 간에 인스턴스 내부의 값을 변경해야 하는 메서드를 요구하려면 프로토콜의 메서드 정의 앞에 mutating 키워드를 명시해야만 함 But, 프로토콜에 mutating 키워드를 사용한 메소드 요구가 있다 하더라도 클래스 구현에서는 mutating 키워드를 써주지 않아도 됨.

#### 이니셜라이저 요구
특정한 이니셜라이저를 요구할 수 있음.<br>
구조체는 상속할 수 없기 때문에 이니셜라이저 요구에 신경쓸 필요 X But 클래스는 상속이 가능하기에 이니셜라이져 요구에 대해 **required** 식별자를 붙여야 함. 이는 상속 받는 모든 클래스가 프로토콜의 이니셜라이져 요구를 준수해야함을 의미.

### 클래스 전용 프로토콜
프로토콜의 상속 리스트에 class 키워드를 추가해 프로토콜이 클래스 타입에만 채택될 수 있도록 제한할 수 있음. 클래스 전용 프로토콜로 제한을 주기 위해서는 프로토콜의 상속 리스트의 맨 처음에 class 키워드가 위치해야만 함

### 프로토콜 조합과 프로토콜 준수 확인
하나의 매개변수가 여러 프로토콜을 모두 준수하는 타입이어야 한다면 하나의 매개변수에 여러 프로토콜을 한 번에 조합하여 요구할 수 있음<br>
**SomeProtocol & AnotherProtocol** 과 같이 표현. 이렇게 &를 붙여 여러 프로토콜 이름 사이에 써주면 됨

### 프로토콜의 선택적 요구
프로토콜의 요구사항 중 일부를 선택적 요구사항으로 지정할 수 있음<br>
선택적 요구사항을 정의하고 싶은 프로토콜은 **objc** 속성이 부여된 프로토콜이어먄 함. objc 속성은 해당 프로토콜을 Objective-C 코드에서 사용할 수 있도록 만드는 역할 하지만 굳이 Objective-C 코드와 공유하지 않더라도 objc 속성이 부여되어야만 선택적 요구사항을 정의할 수 있음 하지만 이 뜻은 열거형이나 구조체 등에서는 objc 속성이 부여된 프로토콜은 아예 채택할 수 없다는 것을 의미<br>
선택적 요구를 하면 프로토콜을 준수하는 타입에 해당 요구사항을 필수로 구현할 필요는 없음. **선택적 요구사항은 optional 식별자를 요구사항의 정의 앞에 붙여주면 됨**

****

## 제네릭
### 제네릭 함수
제네릭을 이용해 코드를 구현하는 어떤 타입에도 유연하게 대응이 가능. 제네릭으로 구현한 기능과 타입은 재사용이 용이하고 코드의 중복을 줄여 추상적 표현이 가능<br>
제네릭이 필요한 타입 또는 메서드의 이름 뒤에 화살괄호 기호(<>) 사이에 제네릭을 위한 타입 매개변수를 써주어 제네릭을 사용할 것임을 표시<br>
- Ex] <br>
제네릭을 사용하고자 하는 타입 이름 <타입 매개변수><br>
제네릭을 사용하고자 하는 함수 이름 <타입 매개변수> (함수의 매개변수...)

<br><br>
 제네릭 함수는 실제 타입 이름(Int, String 등)을 써주는 대신에 플레이스홀더(placeholder)를 사용.<br>
 플레이스 홀더는 타입의 종류를 알려주지 않지만 어떤 타입인지는 알려줌. 즉, 매개변수로 같은 플레이스홀더 타입인 두 매개변수가 있는 경우 두 매개변수가 같은 타입이라는것 정도는 알수 있음
 플레이스 홀더 타입은 함수가 호출되는 그 순간 결정됨

### 제네릭 타입
제네릭 타입을 구현시 사용자 정의 타입인 구조체, 클래스, 열거형 등이 어떤 타입과도 연관되어 동작이 가능.(Array와 Dictionary 타입이 자신의 요소로 모든 타입을 대상으로 동작할 수 있는 것과 유사)

### 제네릭 타입 확장
만약 extension을 통해 제네릭을 사용하는 타입에 기능을 추가하고자 할때 익스텐션 정의에 타입 매개변수를 명시하지 않아야 함. 대신 원래의 제네릭 정의에 명시한 타입 매개변수를 익스텐션에서 사용할 수 있음

### 타입 제약
제네릭 함수가 처리해야 할 기능이 특정 타입에 한정되어야만 처리할 수 있다던가, 제네릭 타입을 특정 프로토콜을 따르는 타입만 사용할 수 있도록 제약을 두어야 하는 상황이 있음. 이 때 사용하는것이 타입 제약(Type Constraints)<br>
**타입제약은 클래스 타입 또는 프로토콜로만 줄 수 있음. 즉 열거형, 구조체 등의 타입은 타입 제약의 타입으로 사용이 불가능함.**<br>
**제네릭 타입에 제약을 주고 싶다면 타입 매개변수 뒤에 콜론을 붙인 후 원하는 클래스 타입 또는 프로토콜을 명시하면 됨**<br>
Ex] func swapTwoValues<T: BinaryInteger>(_ a:inout T, _ b:inout T,)<br>
**여러제약을 주고싶다면 콤바보다는 where절을 사용할수도 있음**
<br>
Ex] func swapTwoValues<T: BinaryInteger>(_ a:inout T, _ b:inout T,) where T: FloatingPoint

****

## 맵, 필터, 리듀스
매개변수로 함수를 갖는 함수를 고차함수라 함
### 맵
맵(Map)은 자신을 호출할 때 매개변수로 전달된 함수를 실행하여 그 결과를 다시 반환해주는 함수. 스위프트에서 맵은 배열, 딕셔너리, 세트, 옵셔널 등에서 사용 가능 정확히 말하자면 스위프트의 Sequence, Collection 프로토콜을 따르는 타입과 옵셔널은 모두 맵을 사용가능<br>
**맵은 기존 데이터를 변형하는데 많이 사용**

### 필터
**필터(Filter)는 말그대로 컨테이너 내부의 값을 걸러서 추출하는 역할을 하는 고차함수**
맵과 마찬가지로 새로운 컨테이너에 값을 담아 반환해줌. But, 맵처럼 기존 콘텐츠를 변형하는 것이 아닌, 특정 조건에 맞게 걸러내는 역할을 함<br>
filter 함수의 매개변수로 전달되는 하뭇의 반환 타입은 Bool, 해당 콘텐츠의 값을 갖고 새로운 컨테이너에 포함될 항목이라 판단시 true를, 그렇지 않을시 false를 반환.

 ### 리듀스
 리듀스(Reduce) 기능은 결합의 기능. 리듀스는 컨테이너 내부의 컨텐츠를 하나로 합하는 기능을 실행하는 고차함수(Ex] 배열이라면 배열의 모든 값을 전달인자로 전달받은 클로저의 연산 결과로 합해줌)<br>
 스위프트의 리듀스는 2가지 형태로 구현<br>
 1. 클로저가 각 요소를 전달받아 연산한 후 값을 다음 클로저 실행을 위해 반환하며 컨테이너를 순환하는 형태
 2. 컨테이너를 순환하며 클로저가 실행되지만 클로저가 따로 결과값을 반환하지 않는 형태

## 서브스크립트
클래스, 구조체, 열거형에는 컬렉션, 리스트, 스퀀스 등 타입의 요소에 접근하는 단축 문법인 서브스크립트(subscript)정의가 가능. 서브스크립트는 별도의 설정자(setter) 또는 접근자(getter)등의 메서드를 구현하지 않아도 인덱스를 통해 값을 설정하거나 가져올수 있게끔 만들어줌<br>
서브스크립트는 인스턴스의 이름 뒤에 대괄호로 감싼 값을 써줌으로써 인스턴스 내부의 특정 값에 접근이 가능<br>
서브스크립트는 **subscript** 키워드를 사용. 읽고 쓰고가 가능하거나 읽기 전용으로만 구현도 가능
### 타입 서브스크립트
타입 서브스크립트는 인스턴스가 아닌 타입 자체에서 사용할 수 있는 서브스크립트 타입 서브스크립트 구현하기 위해선 서브스크립트 정의시 subscript 키워드 앞에 static 키워드를 붙이면 됨. 클래스의 경우 class 키워드를 사용

## 프로토콜 지향 프로그래밍
프로토콜을 정의할 때는 그 프로토콜올 채택한 타입에서 구현해주어야 하는 프로토콜의 요구사항을 구현할 수 없음. (단지 그 요구사항을 정의할 수만 있을뿐) But 프로토콜의 익스텐션에는 프로토콜이 요구하는 기능을 실제로 구현해줄 수 있음. 다만 익스텐션에는 저장 프로퍼티를 구현할 수 없으므로 저장 프로퍼티는 각각의 타입에서 직접 구현해야 함<br>
이처럼 프로토콜의 요구사항을 익스텐션을 통해 구현하는 것을 **프로토콜 초기구현(Protocol Default Implementation)** 이라 함

# Advanced Swift

****

## 타입 중첩
Swift에는 타입 내부에 타입을 정의하고 구현할 수 있음. 이처럼 타입 내부에 새로운 타입을 선언해준 것을 중첩 타입(Nested Types)이라고 부름
1. 중첩 데이터 타입
   <br>클래스 내부에 새 클래ㅐ스, 클래스 내부에 새 구조체, 구조체 내부에 새 열거형 등의 타입을 중첩해서 타입 내부에 새 타입을 정의할 수 있음 

타입 중첩은 이름이 같더라도 역할이 달라야 하는 경우에 사용됨

## 패턴(Pattern)
스위프트에는 문법에 응용할 수 있는 다양한 종류의 패턴(pattern)이 존재<br>
대부분의 패턴은 switch 구문에서 강력한 힘을 발휘함<br>
스위프트의 패턴은 크게 두 종류로 나뉨
- 값을 해체(추출)하거나 무시하는 패턴
  - 와일드카드 패턴, 식별자 패턴 값 바인딩 패턴, 튜플 패턴
- 패턴 매칭을 위한 패턴
  - 열거형 케이스 패턴, 옵셔널 패턴 표현 패턴, 타입캐스팅 패턴

### 와일드카드 패턴
와일드카드 식별자(_)를 사용한다는 것은 '이 자리에 올 것이 무엇이든간에 상관하지 마라'는 뜻, 즉 와일드카드 식별자가 위치한 곳의 값은 무시함

### 값 바인딩 패턴
변수 또는 상수의 이름에 매치된 값을 바인딩하는 것

### 튜플 패턴
튜플 패턴(Tuple Pattern)은 소괄호(**()**) 내에 쉼표로 분리하는 리스트
<br>튜플 패턴을 for-in 구문 또는 변쑤나 상수 선언에서 사용한다면 와일드카드 패턴, 식별자 패턴, 옵셔널 패턴, 또다른 튜플 패턴 등을 함께 사용이 가능

### 열거형 케이스 패턴
열거형 케이스 패턴(Enumeration Case Pattern)은 값을 열거형 타입의 **case**와 매치시킴<br>
열거형 케이스 패턴은 switch구문의 case 레이블과 if, while, guard, for-in 구문의 case 조건에서 볼 수 있음

### 옵셔널 패턴
옵셔널 또는 암시적 추출 옵셔널 열거형에 감싸져 있는 값을 매치시킬 때 사용<br>
옵셔널 패턴은 식별자 패턴 뒤에 물음표를 넣어 표기, 열거형 케이스 패턴과 동일한 위치에 자리함 <br>
또, 옵셔널 패턴은 옵셔널 값을 저장하는 배열의 for-in 구문을 통한 순환에서 nil이 아닌 값을 찾는 데도 유용하게 사용함

### 타입캐스팅 패턴
- **is 패턴**
- **as 패턴**

#### is 패턴
switch의 case 레이블에서만 사용이 가능 <br>
is 패턴은 **is (TYPE_NAME)**과 같이 사용이 가능

#### as 패턴
**SomePattern as (TYPE_NAME)** 과 같이 사용이 가능
<br><br>
타입 캐스팅 패턴은 타입캐스팅 하거나 타입을 매치 시킴

### 표현 패턴
표현식의 값을 평가한 결과를 이용하는 것. 표현 패턴은 switch 구문의 case 레이블에서만 사용이 가능<br>
표현 패턴은 정수값과 정수의 범위를 나타내는 Range객체와 매치시킬수도 있음

****

## where 절
특정 패턴과 결합하여 조건을 추가하는 역할을 함. 조건을 더 추가하고 싶을 때, 특정 타입에 제한을 두고 싶을 때 등등 다양한 용도로 사용이 가능함

### where 절의 활용
- 패턴과 결합하여 조건 추가
- 타입에 대한 제약 추가

프로토콜 extension에 where절을 사용하면 이 extension이 특정 프로토콜을 준수하는 타입에만 저용될 수 있도록 제약을 주는것이 가능해짐.<br> ==> 즉, extension이 적용된 프로토콜을 준수하는 타입 중 where 절 뒤에 제시되는 프로토콜도 준수하는 타입만 extension이 적용되도록 제약을 주는것이 가능해짐<br><br>
Ex] extension SelfPrintable where Self: Container <br>
'SelfPrintable' 프로토콜을 준수하는 타입 중 Container 프로토콜도 준수하는 타입에만 이 익스텐션이 적용될수 있다는 의미